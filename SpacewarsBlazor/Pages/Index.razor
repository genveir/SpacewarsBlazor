@page "/"
@inject IJSRuntime jsRunTime
@inject Player player
<div tabindex="0" @onkeydown="KeyDown" @onkeyup="KeyUp">
    <div class="row align-items-center">
        <div class="col">
            <div class="container-canvas">
                <BECanvas Width="@Game.MaxX" Height="@Game.MaxY" @ref="_canvasReference"></BECanvas>
            </div>
        </div>
    </div>
</div>

@code {
    private Canvas2DContext _context;

    protected Blazor.Extensions.BECanvasComponent _canvasReference;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Game.Subscribe(player);

            this._context = await this._canvasReference.CreateCanvas2DAsync();

            await jsRunTime.InvokeAsync<object>("subscribeToAnimationLoop", DotNetObjectReference.Create(this));
        }
    }

    protected void KeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "ArrowUp") player.Commands.Accelerate = false;
        if (e.Key == "ArrowLeft") player.Commands.TurnLeft = false;
        if (e.Key == "ArrowRight") player.Commands.TurnRight = false;
    }

    protected void KeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "ArrowUp") player.Commands.Accelerate = true;
        if (e.Key == "ArrowLeft") player.Commands.TurnLeft = true;
        if (e.Key == "ArrowRight") player.Commands.TurnRight = true;
        if (e.CtrlKey) player.Commands.Fire = true;
    }

    [JSInvokable]
    public async ValueTask RenderFrame(float timeStamp)
    {
        player.Touch();

        await this._context.BeginBatchAsync();

        if (player.Inactive) await this._context.SetFillStyleAsync("#ff0000");
        else if (player.CurrentlyDead) await this._context.SetFillStyleAsync("#400000");
        else await this._context.SetFillStyleAsync("#000040");

        await this._context.FillRectAsync(0, 0, Game.MaxX, Game.MaxY);

        await this._context.BeginPathAsync();
        await this._context.ArcAsync(player.X, player.Y, 20, 0, 2 * Math.PI, false);
        await this._context.SetStrokeStyleAsync("#ffffff");
        await this._context.StrokeAsync();

        var allPlayers = Game.PlayerSnapshot;
        foreach (var _player in allPlayers)
        {
            await DrawShip(_player);
        }

        var allBullets = Game.BulletSnapshot;
        foreach (var _bullet in allBullets)
        {
            await DrawBullet(_bullet);
        }

        await this._context.EndBatchAsync();
    }

    private async Task DrawShip(Player _player)
    {
        var clr = _player.Color;
        if (_player.CurrentlyDead) clr = "#ff0000";

        await this._context.SaveAsync();

        await this._context.TranslateAsync(_player.X, _player.Y);
        await this._context.RotateAsync(_player.Heading);
        await this._context.TranslateAsync(-_player.X, -_player.Y);

        await this._context.BeginPathAsync();
        await this._context.ArcAsync(_player.X, _player.Y - (_player.Size / 2), _player.Size, 0, Math.PI, false);
        await this._context.SetFillStyleAsync(clr);
        await this._context.FillAsync();

        await this._context.BeginPathAsync();
        await this._context.ArcAsync(_player.X, _player.Y, _player.Size, 0, 0.5 * Math.PI, false);
        await this._context.SetFillStyleAsync(clr);
        await this._context.FillAsync();

        await this._context.BeginPathAsync();
        await this._context.ArcAsync(_player.X, _player.Y, _player.Size, 0.5 * Math.PI, Math.PI, false);
        await this._context.SetFillStyleAsync(clr);
        await this._context.FillAsync();

        await this._context.RestoreAsync();
    }

    private async Task DrawBullet(Bullet _bullet)
    {
        await this._context.BeginPathAsync();
        await this._context.ArcAsync(_bullet.X, _bullet.Y, _bullet.Size, 0, 2 * Math.PI, false);
        await this._context.SetFillStyleAsync(_bullet.Color);
        await this._context.FillAsync();
    }
}
